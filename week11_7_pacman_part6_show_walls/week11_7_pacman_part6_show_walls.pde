//week11_7_pacman_part6_show_walls
//改自 week11_6
//小精靈張嘴在動 而且嘴巴的方向 dir 會轉動
void setup(){
  size(600, 600); //改一下視窗的大小, 讓它是 30 的倍數
}
int x = 300-15, y = 300-15, dx = 0, dy = 0, dir = 0; //direction
float m = 0, dm = 0.05; //嘴巴大小mouth, 嘴巴改變量diff of m
boolean [][] bean_eaten = new boolean[20][20]; //Java 的二維陣  //用來標記每顆豆子是否被吃掉的二維陣列
int [][] walls = { //二維陣列表示牆壁的佈局，1代表牆壁， 0代表空地
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, //20個0,代表沒有牆
  {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0}, //中間都是牆
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 
  {0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,0}, 
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, 
  {0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0}, 
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0},
  {0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
  {0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0},
  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
};
void draw(){
  background(0);
  boolean canMoveX = true, canMoveY = true; //用來檢查小精靈是否能在 X 和 Y 軸方向上移動
  //繪製牆壁與檢查小精靈是否碰到牆壁
  for (int i=0; i<20; i++) { //左手i 對應 y座標
    for (int j=0; j<20; j++) { //右手j 對應 x座標
      if ( walls[i][j]==1 ) {
        fill(255); //白色方塊牆
        rect( j*30, i*30, 30, 30);
        if (j*30 <= x+dx*15 && x+dx*15 <= j*30+30 && i*30 <= y    && y    <= i*30+30) canMoveX = false; //如果小精靈與牆壁重疊，禁止在 X 軸方向上移動
        if (j*30 <= x    && x    <= j*30+30 && i*30 <= y+dy*15 && y+dy*15 <= i*30+30) canMoveY = false; //如果小精靈與牆壁重疊，禁止在 Y 軸方向上移動
      } else if ( bean_eaten[i][j]==false ) { //如果該位置沒有牆壁且豆子未被吃掉
        fill(255); //白色的豆子
        ellipse( 15 + j*30, 15 + i*30, 5, 5); //檢查小精靈是否吃到豆子
        if ( dist(x,y, 15 + j*30, 15 + i*30) < 15 ) bean_eaten[i][j] = true;
      }
    }
  }
  //繪製小精靈（黃色圓形）
  fill(255,255,0); //黃色的
  float m0 = dir * PI/2; //幾個「半PI」 有幾個90度
  arc(x, y, 30, 30, m0 + m, m0 + PI*2 - m); //弧度
  //轉折點邏輯，當小精靈到達一個轉折點時，根據 `next` 設定方向
  if (x+dx >= 15 && x+dx <= 600-15 && canMoveX) x += dx; //改變座標 (不超過四週的牆)
  if (y+dy >= 15 && y+dy <= 600-15 && canMoveY) y += dy; //改變座標 (不超過四週的牆)
  //豆子、轉折點 座標 (15 + j*30, 15 + i*30)
  if ( (x-15)%30 == 0 && (y-15)%30 == 0 ) {
    if (next==2) { dx = -1; dy = 0; dir = 2; } //dir:2 向左 PI
    if (next==0) { dx = +1; dy = 0; dir = 0; } //dir:0 向右 0度
    if (next==3) { dx = 0; dy = -1; dir = 3; } //dir:3 向上 PI*1.5
    if (next==1) { dx = 0; dy = +1; dir = 1; } //dir:1 向下 PI/2
    next = -1; //沒有要轉動哦!
  }
  
  if (m>=1 || m<0) dm = -dm; //正負倒過來
  m += dm;
}
int next = -1; //一開始沒有要轉動
void keyPressed() { //按下方向鍵, 會決定下一步 next 要怎麼做
  if (keyCode==LEFT) next = 2;
  if (keyCode==RIGHT)next = 0;
  if (keyCode==UP)   next = 3;
  if (keyCode==DOWN) next = 1;
}
